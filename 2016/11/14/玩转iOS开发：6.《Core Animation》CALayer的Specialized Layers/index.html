
<!DOCTYPE html>
<html lang="zh-cn" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>玩转iOS开发：6.《Core Animation》CALayer的Specialized Layers - iOS Development</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="在上一篇文章《Core Animation》CALayer的Transforms中, 我们了解了二维空间和三维空间的一些布局, 还有就是最简单的旋转, 平移之类的, 再来一些就是混合使用的, 这次我,"> 
    <meta name="author" content="CainLuo"> 
    <link rel="alternative" href="atom.xml" title="iOS Development" type="application/atom+xml"> 
    <link rel="icon" href="/iOSDevelopment/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/iOSDevelopment/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">iOS Development</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://cainluo.github.io/iOSDevelopment"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">玩转iOS开发：6.《Core Animation》CALayer的Specialized Layers</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">玩转iOS开发：6.《Core Animation》CALayer的Specialized Layers</h1>
        <div class="stuff">
            <span>十一月 14, 2016</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/iOSDevelopment/tags/Core-Animation/">Core Animation</a></li></ul>


        </div>
        <div class="content markdown">
            <p>在上一篇文章<a href="https://CainLuo.github.io/14777052484078.html">《Core Animation》CALayer的Transforms</a>中, 我们了解了二维空间和三维空间的一些布局, 还有就是最简单的旋转, 平移之类的, 再来一些就是混合使用的, 这次我们来换个话题.</p>
<blockquote>
<p>最后: 如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注<strong><code>Core Animation</code></strong>如果觉得好的话, 希望大家也可以打赏一下<del>嘻嘻</del>祝大家学习愉快<del>谢谢</del></p>
</blockquote>
<p><strong>转载声明:如需要转载该文章, 请联系作者, 并且注明出处, 以及不能擅自修改本文.</strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Specialized Layers</strong>讲得是一些专用的一些图层类, 而不是之前所说的一些用于图片, 颜色之类的, 下面让我们来看看吧~</p>
<h2 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h2><p>在之前的文章里, 我们使用过阴影效果, 并且是不使用<strong>CGPath</strong>情况下去构建形状不同的阴影, 在<strong>CALayer</strong>中, 有一个子类叫做<strong>CAShapeLayer</strong>, 它也是可以做到对应的效果.</p>
<p><strong>CAShapeLayer</strong>是一个通过矢量图形来进行绘制的图层子类, 而并不是使用<strong>Bitmap</strong>, 当我们指定对应的颜色, 线宽等属性, 就可以使用<strong>CGPath</strong>来绘制我们想要的形状, 最后<strong>CAShapeLayer</strong>就自动渲染出来了, 当然你也可以使用<strong>Core Graphics</strong>直接对一个<strong>CALayer</strong>进行绘制, 但<strong>CAShapeLayer</strong>要比<strong>Core Graphics</strong>直接操作<strong>CALayer</strong>要好一些, 比如:</p>
<ul>
<li><strong>CAShapeLayer</strong>使用了硬件加速, 绘制同一图形时会比<strong>Core Graphics</strong>渲染的快.</li>
<li><strong>CAShapeLayer</strong>不需要像普通<strong>CALayer</strong>一样创建一个寄宿图形, 所以无论有多大, 都不会占用太多的内存.</li>
<li><strong>CAShapeLayer</strong>和<strong>Core Graphics</strong>不一样, 它并不会被图层边界给裁剪掉.</li>
<li><strong>CAShapeLayer</strong>不会出现像素化, 这可以提现在, 用<strong>CAShapeLayer</strong>做3D变换的时候, 不会和普通的图层一样出现像素化.</li>
</ul>
<h3 id="创建一个CGPath"><a href="#创建一个CGPath" class="headerlink" title="创建一个CGPath"></a>创建一个CGPath</h3><p>刚刚说了, <strong>CAShapeLayer</strong>可以通过<strong>CGPath</strong>来绘制任意图形, 并且可以设置一些属性, 比如<strong>lineWith</strong>, <strong>lineCap</strong>, <strong>lineJoin</strong>.</p>
<p>我们绘制这个图形的时候, 不一定要闭合, 图层路径也不是绝对, 可以在一个图层上绘制多个不同的图形, 当然, 如果你要想用不同的颜色风格来绘制N个图形, 那你就要准备好多个<strong>Layer</strong>了.</p>
<p><strong>CAShapeLayer</strong>是属于<strong>CGPathRef</strong>类型, 但在实际开发中, 我们是用<strong>UIBezierPath</strong>来创建图层路径的, 这样子我们就不用考虑人工释放<strong>CGPath</strong>了, 下面让我们来看Demo吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)createPath &#123;</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [[UIBezierPath alloc] init];</span><br><span class="line">    </span><br><span class="line">    [path moveToPoint:CGPointMake(175, 100)];</span><br><span class="line">    [path addQuadCurveToPoint:CGPointMake(100, 500)</span><br><span class="line">                 controlPoint:CGPointMake(250, 600)];</span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *shapeLayer = [CAShapeLayer layer];</span><br><span class="line">    shapeLayer.strokeColor = [UIColor blueColor].CGColor;</span><br><span class="line">    shapeLayer.fillColor = [UIColor clearColor].CGColor;</span><br><span class="line">    shapeLayer.lineWidth = 10;</span><br><span class="line">    shapeLayer.lineJoin = kCALineJoinRound;</span><br><span class="line">    shapeLayer.lineCap = kCALineCapRound;</span><br><span class="line">    shapeLayer.path = path.CGPath;</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:shapeLayer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/1.png" alt="1"><br><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/2.png" alt="2"></p>
<h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><p>之前我们在之前的文章里, 有提到过把一个视图剪切成圆角, 用的就是<strong>CALayer</strong>的<strong>cornerRadius</strong>属性, 而<strong>CAShapeLayer</strong>类也可以提供同样的功能, 虽然代码多了一些, 但也多了一些灵活, 它可以指定单独的指定每个角.</p>
<p>我们创建圆角矩形其实就是人工绘制单独的直线和弧度, 但在<strong>UIBezierPath</strong>中有提供自动绘制圆角矩形的方法, 直接看代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewRoundedCorners &#123;</span><br><span class="line">    </span><br><span class="line">    CGRect rect = CGRectMake(130, 130, 100, 100);</span><br><span class="line">    CGSize radii = CGSizeMake(10, 10);</span><br><span class="line">    </span><br><span class="line">    UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft | UIRectCornerTopLeft;</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect</span><br><span class="line">                                               byRoundingCorners:corners</span><br><span class="line">                                                     cornerRadii:radii];</span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *shapeLayer = [CAShapeLayer layer];</span><br><span class="line">    </span><br><span class="line">    shapeLayer.path = path.CGPath;</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:shapeLayer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/3.png" alt="3"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/4.png" alt="4"></p>
<h3 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h3><p>如果我们想在一个图层里显示文字, 我们可以借助和<strong>UILabel</strong>一样的方式, 使用<strong>Core Graphics</strong>在图层上写入内容, 但如果要越过<strong>UILabel</strong>这些控件, 直接在图层上显示文字的话, 我们就要为每个显示文字的图层创建一个图层代理的类, 并且判断哪个图层需要显示哪个字符串, 如果再加一些字体, 颜色一些乱七八糟的东西, 那就蛋疼的不要不要的.</p>
<p>好在<strong>CALayer</strong>里有一个子类, 叫做<strong>CATextLayer</strong>, 它几乎都包含了<strong>UILabel</strong>的所有绘制特性, 而且还额外提供了一些新特性, 并且在渲染的速度上, 要比<strong>UILabel</strong>快的多, 偷偷说个事, 在<strong>iOS 6</strong>之前, <strong>UILabel</strong>其实是通过<strong>WebKit</strong>来实现绘制的, 所以那时候<strong>iOS</strong>在渲染文字的时候会有非常大的性能问题, 但<strong>CATextLayer</strong>使用的是<strong>Core Text</strong>, 两者之前完全不同一个概念.</p>
<p>说那么多废话, 直接上代码吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)catextLayer &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *labelView = [[UIView alloc] initWithFrame:CGRectMake(30, 100, 300, 300)];</span><br><span class="line">    </span><br><span class="line">    labelView.backgroundColor = [UIColor redColor];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:labelView];</span><br><span class="line">    </span><br><span class="line">    CATextLayer *textLayer = [CATextLayer layer];</span><br><span class="line">    textLayer.frame = labelView.bounds;</span><br><span class="line">    </span><br><span class="line">    [labelView.layer addSublayer:textLayer];</span><br><span class="line">    </span><br><span class="line">    textLayer.foregroundColor = [UIColor blackColor].CGColor;</span><br><span class="line">    textLayer.alignmentMode = kCAAlignmentJustified;</span><br><span class="line">    textLayer.wrapped = YES;</span><br><span class="line">    </span><br><span class="line">    UIFont *font = [UIFont systemFontOfSize:15];</span><br><span class="line">    </span><br><span class="line">    CFStringRef fontName = (__bridge CFStringRef)font.fontName;</span><br><span class="line">    CGFontRef fontRef = CGFontCreateWithFontName(fontName);</span><br><span class="line">    </span><br><span class="line">    textLayer.font = fontRef;</span><br><span class="line">    textLayer.fontSize = font.pointSize;</span><br><span class="line">    </span><br><span class="line">    CGFontRelease(fontRef);</span><br><span class="line">    </span><br><span class="line">    NSString *text = @&quot;这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字&quot;;</span><br><span class="line">    </span><br><span class="line">    textLayer.string = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还要多说一句, 如果你发现文本显示的时候出现像素化的时候, 只要加上以下这段代码, 就哦了, 它会以<strong>Retina</strong>模式来渲染:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textLayer.contentsScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/5.png" alt="5"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/6.png" alt="6"></p>
<p><strong>contentsScale</strong>并且并不关心屏幕的拉伸, 因为默认都是<strong>1.0f</strong>, 所以我们要高清, 那就设置它吧.</p>
<p><strong>CATextLayer</strong>里的<strong>font</strong>属性, 其实并不是一个真正的<strong>UIFont</strong>类型, 而是一个<strong>CFTypeRef</strong>类型, 这样子就可以根据我们的需求来决定字体的属性到底是用<strong>CGFontRef</strong>类型还是用<strong>Core Text</strong>里的<strong>CTFontRef</strong>类型了, 同时字体大小也是用<strong>fontSize</strong>属性单独设置的, 因为<strong>CTFontRef</strong>和<strong>CGFontRef</strong>和<strong>UIFont</strong>完全是两回事, 在代码中我们也知道了如何将<strong>UIFont</strong>转成<strong>CGFontRef</strong>.</p>
<p>当然<strong>CATextLayer</strong>里的<strong>string</strong>属性是<strong>id</strong>类型, 并不是我们想象中的<strong>NSString</strong>类型, 因为这样子我们就可以用<strong>NSString</strong>也可以用<strong>NSAttributedString</strong>来指定要显示的文本, 比如指定某段文字的字体, 颜色, 字重, 斜体等等.</p>
<h3 id="Rich-Text"><a href="#Rich-Text" class="headerlink" title="Rich Text"></a>Rich Text</h3><p>其实在<strong>iOS 6</strong>的时候, <strong>Apple</strong>就已经给了<strong>UILabel</strong>和其他的<strong>UIKit</strong>文本视图添加直接的属性, 但事实上, 在<strong>iOS 3.2</strong>的时候, <strong>CATextLayer</strong>就已经支持属性化字符串了, 如果你想支持更低版本的<strong>iOS</strong>那么你可以使用<strong>CATextLayer</strong>, 不需要和更复杂的<strong>Core Text</strong>打交道, 也省略了使用其他的方法, 但现在又会有哪家公司支持低版本的<strong>iOS</strong>呢? 但不能够说在新版本的<strong>iOS</strong>D昂中<strong>CATextLayer</strong>就无用功了, 这个得看我们的需求来确定了.</p>
<p>这次我们把<strong>Core Text</strong>, <strong>CATextLayer</strong>, <strong>NSAttributedString</strong>三者混在一起使用一下~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)attributedString &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *labelView = [[UIView alloc] initWithFrame:CGRectMake(0, 200, self.view.frame.size.width, 400)];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:labelView];</span><br><span class="line">    </span><br><span class="line">    CATextLayer *textLayer = [CATextLayer layer];</span><br><span class="line">    </span><br><span class="line">    textLayer.frame = labelView.bounds;</span><br><span class="line">    textLayer.contentsScale = [UIScreen mainScreen].scale;</span><br><span class="line">    </span><br><span class="line">    [labelView.layer addSublayer:textLayer];</span><br><span class="line">    </span><br><span class="line">    textLayer.alignmentMode = kCAAlignmentJustified; textLayer.wrapped = YES;</span><br><span class="line">    </span><br><span class="line">    UIFont *font = [UIFont systemFontOfSize:15];</span><br><span class="line"></span><br><span class="line">    NSString *text = @&quot;这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字&quot;;</span><br><span class="line">    </span><br><span class="line">    NSMutableAttributedString *string = nil;</span><br><span class="line">    string = [[NSMutableAttributedString alloc] initWithString:text];</span><br><span class="line">    </span><br><span class="line">    CFStringRef fontName = (__bridge CFStringRef)font.fontName; CGFloat fontSize = font.pointSize;</span><br><span class="line">    CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);</span><br><span class="line">    </span><br><span class="line">    NSDictionary *attribs = @&#123;(__bridge id)kCTForegroundColorAttributeName : (__bridge id)[UIColor blackColor].CGColor,</span><br><span class="line">                              (__bridge id)kCTFontAttributeName: (__bridge id)fontRef&#125;;</span><br><span class="line">    </span><br><span class="line">    [string setAttributes:attribs range:NSMakeRange(0, [text length])];</span><br><span class="line">    </span><br><span class="line">    attribs = @&#123;(__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,</span><br><span class="line">                (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),</span><br><span class="line">                (__bridge id)kCTFontAttributeName: (__bridge id)fontRef&#125;;</span><br><span class="line">    </span><br><span class="line">    [string setAttributes:attribs range:NSMakeRange(6, 20)];</span><br><span class="line">    </span><br><span class="line">    CFRelease(fontRef);</span><br><span class="line">    </span><br><span class="line">    textLayer.string = string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/7.png" alt="7"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/8.png" alt="8"></p>
<h3 id="Leading-and-Kerning"><a href="#Leading-and-Kerning" class="headerlink" title="Leading and Kerning"></a>Leading and Kerning</h3><p>这里有个点, 由于<strong>Core Text</strong>和<strong>WebKit</strong>的内部实现机制不同, 用<strong>CATextLayer</strong>渲染或者是用<strong>UILabel</strong>渲染文本行距和字距也是不一样的, 这个是由使用字体和字符来决定的, 所以大家如果要使用普通的<strong>UILabel</strong>和<strong>CATextLayer</strong>, 就要好好注意一下了.</p>
<h3 id="A-UILabel-Replacement"><a href="#A-UILabel-Replacement" class="headerlink" title="A UILabel Replacement"></a>A UILabel Replacement</h3><p>这次我们就自己创建一个属于我们自己的<strong>UILabel</strong>, 代替系统的<strong>UILabel</strong>, 虽然这个类也是继承于<strong>UILabel</strong>, 但比系统的<strong>UILabel</strong>的<strong>-drawRect:</strong>方法要快, 来看看代码吧~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CLLabel.h&quot;</span><br><span class="line">#import &lt;QuartzCore/QuartzCore.h</span><br><span class="line"></span><br><span class="line">@implementation CLLabel</span><br><span class="line"></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    </span><br><span class="line">    return [CATextLayer class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CATextLayer *)textLayer &#123;</span><br><span class="line">    </span><br><span class="line">    return (CATextLayer *)self.layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUp &#123;</span><br><span class="line">    </span><br><span class="line">    self.text = self.text;</span><br><span class="line">    self.textColor = self.textColor;</span><br><span class="line">    self.font = self.font;</span><br><span class="line">    </span><br><span class="line">    [self textLayer].wrapped = YES;</span><br><span class="line">    [self.layer display];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    </span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        </span><br><span class="line">        [self setUp];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">    </span><br><span class="line">    [self setUp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setText:(NSString *)text &#123;</span><br><span class="line">    super.text = text;</span><br><span class="line">    </span><br><span class="line">    [self textLayer].string = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setTextColor:(UIColor *)textColor &#123;</span><br><span class="line">    super.textColor = textColor;</span><br><span class="line">    </span><br><span class="line">    [self textLayer].foregroundColor = textColor.CGColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFont:(UIFont *)font &#123;</span><br><span class="line">    super.font = font;</span><br><span class="line">    </span><br><span class="line">    CFStringRef fontName = (__bridge CFStringRef)font.fontName;</span><br><span class="line">    CGFontRef fontRef = CGFontCreateWithFontName(fontName);</span><br><span class="line">    </span><br><span class="line">    [self textLayer].font = fontRef;</span><br><span class="line">    [self textLayer].fontSize = font.pointSize;</span><br><span class="line">    </span><br><span class="line">    CGFontRelease(fontRef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>使用这个自定义的<strong>CLLabel</strong>, 我们看看效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)createCLLabel &#123;</span><br><span class="line">    </span><br><span class="line">    CLLabel *label = [[CLLabel alloc] initWithFrame:CGRectMake(20, 50, 200, 200)];</span><br><span class="line">    </span><br><span class="line">    label.text = @&quot;这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的测试文字&quot;;</span><br><span class="line">    label.textColor = [UIColor blackColor];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:label];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/9.png" alt="9"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/10.png" alt="10"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/11.png" alt="11"></p>
<h3 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h3><p>在我们日常开发当中, 如果需要用到<strong>3D Layer</strong>, 可以用到之前我们说到的<strong>3D Transforms</strong>, 但是那样子太麻烦了, 要算一堆东西, 如果有一种<strong>Layer</strong>可以像玩积木一样, 一个一个的组合成一个<strong>3D</strong>形状的话, 那该多好~</p>
<p>其实<strong>Apple</strong>早就想到了这个问题, 它们提供了<strong>CATransformLayer</strong>, 就是专门用来给<strong>Layer</strong>做一个容器, 然后让拼接成一个看起来像<strong>3D</strong>的一样图形.</p>
<p>我们来看代码: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- (void)transformLayer &#123;</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor = [UIColor grayColor];</span><br><span class="line">    </span><br><span class="line">    CATransform3D transform3DOne = CATransform3DIdentity;</span><br><span class="line">    </span><br><span class="line">    transform3DOne.m34 = -1.0 / 500.0;</span><br><span class="line">    </span><br><span class="line">    self.view.layer.sublayerTransform = transform3DOne;</span><br><span class="line">    </span><br><span class="line">    CATransform3D transform3DTwo = CATransform3DIdentity;</span><br><span class="line">    </span><br><span class="line">    transform3DTwo = CATransform3DTranslate(transform3DTwo, -100, 0, 0);</span><br><span class="line">    </span><br><span class="line">    CALayer *cubeOne = [self cubeWithTransform:transform3DTwo];</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:cubeOne];</span><br><span class="line">    </span><br><span class="line">    CATransform3D transform3DThree = CATransform3DIdentity;</span><br><span class="line">    </span><br><span class="line">    transform3DThree = CATransform3DTranslate(transform3DThree, 100, 0, 0);</span><br><span class="line">    transform3DThree = CATransform3DRotate(transform3DThree, -M_PI_4, 1, 0, 0);</span><br><span class="line">    transform3DThree = CATransform3DRotate(transform3DThree, -M_PI_4, 0, 1, 0);</span><br><span class="line">    </span><br><span class="line">    CALayer *cubeTwo = [self cubeWithTransform:transform3DThree];</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:cubeTwo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CALayer *)layerWithTransform:(CATransform3D)transform &#123;</span><br><span class="line">    </span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    </span><br><span class="line">    layer.frame = CGRectMake(-50, -50, 100, 100);</span><br><span class="line">    </span><br><span class="line">    CGFloat red = (rand() / (double)INT_MAX);</span><br><span class="line">    CGFloat green = (100000 / (double)INT_MAX);</span><br><span class="line">    CGFloat blue = (rand() / (double)INT_MAX);</span><br><span class="line">    </span><br><span class="line">    layer.backgroundColor = [UIColor colorWithRed:red</span><br><span class="line">                                            green:green</span><br><span class="line">                                             blue:blue</span><br><span class="line">                                            alpha:1.0f].CGColor;</span><br><span class="line">    layer.transform = transform;</span><br><span class="line">    </span><br><span class="line">    return layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CALayer *)cubeWithTransform:(CATransform3D)transform &#123;</span><br><span class="line">    </span><br><span class="line">    // cube</span><br><span class="line">    CATransformLayer *cube = [CATransformLayer layer];</span><br><span class="line">    </span><br><span class="line">    // layer one</span><br><span class="line">    CATransform3D transform3D = CATransform3DMakeTranslation(0, 0, 50);</span><br><span class="line">    [cube addSublayer:[self layerWithTransform:transform3D]];</span><br><span class="line">    </span><br><span class="line">    // layer two</span><br><span class="line">    transform3D = CATransform3DMakeTranslation(50, 0, 0);</span><br><span class="line">    transform3D = CATransform3DRotate(transform3D, M_PI_2, 0, 1, 0);</span><br><span class="line">    [cube addSublayer:[self layerWithTransform:transform3D]];</span><br><span class="line">    </span><br><span class="line">    // layer three</span><br><span class="line">    transform3D = CATransform3DMakeTranslation(0, -50, 0);</span><br><span class="line">    transform3D = CATransform3DRotate(transform3D, M_PI_2, 1, 0, 0);</span><br><span class="line">    [cube addSublayer:[self layerWithTransform:transform3D]];</span><br><span class="line"></span><br><span class="line">    // layer five</span><br><span class="line">    transform3D = CATransform3DMakeTranslation(-50, 0, 0);</span><br><span class="line">    transform3D = CATransform3DRotate(transform3D, -M_PI_2, 0, 1, 0);</span><br><span class="line">    [cube addSublayer:[self layerWithTransform:transform3D]];</span><br><span class="line"></span><br><span class="line">    // layer six</span><br><span class="line">    transform3D = CATransform3DMakeTranslation(0, 0, -50);</span><br><span class="line">    transform3D = CATransform3DRotate(transform3D, M_PI, 0, 1, 0);</span><br><span class="line">    [cube addSublayer:[self layerWithTransform:transform3D]];</span><br><span class="line"></span><br><span class="line">    CGSize containerSize = self.view.bounds.size;</span><br><span class="line">    </span><br><span class="line">    cube.position = CGPointMake(containerSize.width / 2.0,</span><br><span class="line">                                containerSize.height / 2.0);</span><br><span class="line">    </span><br><span class="line">    cube.transform = transform;</span><br><span class="line">    </span><br><span class="line">    return cube;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/12.png" alt="12"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/13.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/14.png" alt="14"></p>
<h3 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h3><p>在<strong>Layer</strong>中, 有一种颜色平滑渐变的子类, 叫做<strong>CAGradientLayer</strong>, 虽然用<strong>Core Graphics</strong>也可以通过一些技巧做到和<strong>CAGradientLayer</strong>一样的效果, 但<strong>CAGradieLayer</strong>真正好, 是好在它是用硬件加速来绘制的, 直接来看代码吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)gradientLayer &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *view = [[UIView alloc] init];</span><br><span class="line">    </span><br><span class="line">    view.bounds = CGRectMake(0, 0, 200, 200);</span><br><span class="line">    view.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);</span><br><span class="line">    </span><br><span class="line">    CAGradientLayer *gradientLayer = [CAGradientLayer layer];</span><br><span class="line">    gradientLayer.frame = view.bounds;</span><br><span class="line">    </span><br><span class="line">    // 设置渐变的颜色, 理论上来讲是无限添加的</span><br><span class="line">    gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor,</span><br><span class="line">                             (__bridge id)[UIColor greenColor].CGColor];</span><br><span class="line">    </span><br><span class="line">    gradientLayer.startPoint = CGPointMake(0, 0); // 开始渐变的点</span><br><span class="line">    gradientLayer.endPoint = CGPointMake(1, 1); // 结束渐变的点</span><br><span class="line">    </span><br><span class="line">    gradientLayer.locations = @[@0.0, @0.2]; // 设置渐变的区域</span><br><span class="line">    </span><br><span class="line">    [view.layer addSublayer:gradientLayer];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/15.png" alt="15"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/16.png" alt="16"></p>
<h3 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h3><p>在<strong>CALayer</strong>的子类当中还有一个叫做<strong>CAReplicatorLayer</strong>, 它是用来复制重复的图层, 并且, 你可以给这些复制的图层进行一些属性上的操作, 比如渐变色, 渐变透明, 形状, 还可以加动画效果, 来看看代码吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - CAReplicatorLayer</span><br><span class="line">- (void)replicatorLayer &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *view = [[UIView alloc] init];</span><br><span class="line">    </span><br><span class="line">    view.bounds = CGRectMake(0, 0, 100, 100);</span><br><span class="line">    view.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 4.5);</span><br><span class="line">    </span><br><span class="line">    CATransform3D transform = CATransform3DIdentity;</span><br><span class="line">    </span><br><span class="line">    transform = CATransform3DTranslate(transform, 0, 200, 0);</span><br><span class="line">    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);</span><br><span class="line">    transform = CATransform3DTranslate(transform, 0, -200, 0);</span><br><span class="line"></span><br><span class="line">    CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</span><br><span class="line">    </span><br><span class="line">    replicatorLayer.frame = view.bounds;</span><br><span class="line">    replicatorLayer.instanceCount = 10;  // 复制图层个数</span><br><span class="line">    replicatorLayer.instanceBlueOffset = -1.0f; // 设置每一个图层的逐渐蓝色偏移</span><br><span class="line">    replicatorLayer.instanceRedOffset = -1.0f;  // 设置每一个图层的逐渐红色偏移</span><br><span class="line">    replicatorLayer.instanceAlphaOffset = -0.1f;</span><br><span class="line">    replicatorLayer.instanceDelay = 0.33f;  // 设置每个图层延迟0.33f</span><br><span class="line">    replicatorLayer.instanceTransform = transform;</span><br><span class="line">    </span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    </span><br><span class="line">    layer.frame = CGRectMake(0, 0, 100, 100);</span><br><span class="line">    layer.backgroundColor = [UIColor whiteColor].CGColor;</span><br><span class="line">    </span><br><span class="line">    [replicatorLayer addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor = [UIColor grayColor];</span><br><span class="line">    </span><br><span class="line">    [view.layer addSublayer:replicatorLayer];</span><br><span class="line">    </span><br><span class="line">    [self addLayerAnimation:layer];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addLayerAnimation:(CALayer *)layer &#123;</span><br><span class="line">    </span><br><span class="line">    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;position.y&quot;];</span><br><span class="line">    </span><br><span class="line">    animation.toValue =  @(layer.position.y - 25.0);</span><br><span class="line">    animation.duration = 0.5;</span><br><span class="line">    animation.autoreverses = true;</span><br><span class="line">    animation.repeatCount = CGFLOAT_MAX;</span><br><span class="line">    </span><br><span class="line">    [layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/17.png" alt="17"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/18.gif" alt="18"></p>
<h3 id="Reflections"><a href="#Reflections" class="headerlink" title="Reflections"></a>Reflections</h3><p><strong>CAReplicatorLayer</strong>其实还有一个更加实用的功能, 就是做一个镜面反射的效果, 我们可以自己封装一个<strong>UIView</strong>的类, 也可以自己写一个简单的, 这里我就写个简单点的吧, 大家也可以去<strong>GitHub</strong>里面搜搜, 我在网上搜到一个, 虽然这个库已经2年多没更新了, 但还是值得看看的<a href="https://github.com/nicklockwood/ReflectionView" target="_blank" rel="noopener">ReflectionView</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)reflectionsLayer &#123;</span><br><span class="line">    </span><br><span class="line">    CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</span><br><span class="line">    </span><br><span class="line">    replicatorLayer.instanceCount = 2;</span><br><span class="line">    replicatorLayer.frame = CGRectMake(50, 100, 100, 100);</span><br><span class="line"></span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    </span><br><span class="line">    layer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;github&quot;].CGImage);</span><br><span class="line">    layer.frame = replicatorLayer.bounds;</span><br><span class="line"></span><br><span class="line">    CATransform3D transform = CATransform3DIdentity;</span><br><span class="line">    </span><br><span class="line">    transform = CATransform3DTranslate(transform, 0, layer.bounds.size.height, 0);</span><br><span class="line">    transform = CATransform3DScale(transform, 1, -1, 0);</span><br><span class="line">    </span><br><span class="line">    replicatorLayer.instanceTransform = transform;</span><br><span class="line">    replicatorLayer.instanceAlphaOffset = -0.6;</span><br><span class="line">    </span><br><span class="line">    [replicatorLayer addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:replicatorLayer];</span><br><span class="line">    self.view.backgroundColor = [UIColor grayColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/19.png" alt="19"></p>
<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/20.png" alt="20"></p>
<h3 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h3><p>在<strong>CALayer</strong>的子类当中, 还有一个<strong>CAScrollLayer</strong>, 它可以被称为<strong>UIScrollView</strong>的代替品, 但有一个问题, 我们都知道<strong>Core Animation</strong>是不能处理用户输入, 所以<strong>CAScrollLayer</strong>也不能处理滑动事件, 也不能实现<strong>UIScrollView</strong>那种滑动反弹效果, 但这里加了一个滑动手势就可以实现了滑动效果了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) CAScrollLayer *scrollLayer;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark - CAScrollLayer</span><br><span class="line">- (void)addScrollLayer &#123;</span><br><span class="line">    </span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    </span><br><span class="line">    layer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;github&quot;].CGImage);</span><br><span class="line">    layer.frame = CGRectMake(0, 0, 300, 300);</span><br><span class="line">    </span><br><span class="line">    self.scrollLayer = [CAScrollLayer layer];</span><br><span class="line">    self.scrollLayer.frame = CGRectMake(50, 100, 150, 150);</span><br><span class="line">    self.scrollLayer.scrollMode = kCAScrollBoth;</span><br><span class="line">    self.scrollLayer.backgroundColor = [UIColor grayColor].CGColor;</span><br><span class="line">    </span><br><span class="line">    [self.scrollLayer addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:self.scrollLayer];</span><br><span class="line">    </span><br><span class="line">    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGesture:)];</span><br><span class="line">    </span><br><span class="line">    [self.view addGestureRecognizer:pan];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)panGesture:(UIPanGestureRecognizer *)pan &#123;</span><br><span class="line">    </span><br><span class="line">    CGPoint translocation = [pan translationInView:self.view];</span><br><span class="line">    CGPoint origin = self.scrollLayer.bounds.origin;</span><br><span class="line">    </span><br><span class="line">    origin = CGPointMake(origin.x - translocation.x, origin.y - translocation.y);</span><br><span class="line">    </span><br><span class="line">    [self.scrollLayer scrollToPoint:origin];</span><br><span class="line">    </span><br><span class="line">    [pan setTranslation:CGPointZero inView:self.view];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h3><p>在我们开发当中, 有时候我们会需要加载一张超大的图片, 比如神马4K高清图, 或者是世界地图等等之类的, 但是在<strong>iOS</strong>当中是有内存限制的, 并不像其他系统一样<strong>4G</strong>, <strong>6G</strong>有超大内存, 如果我们要把超大的图片加载到内存当中, 那很明显, 直接会撑爆, 或者是加速速度慢得感人, 如果你是在主线程中使用<strong>UIImage</strong>的<strong>+ (nullable UIImage *)imageNamed:(NSString *)name;</strong>或者是<strong>- (nullable instancetype)initWithContentsOfFile:(NSString *)path</strong>方法来加载图片的话, 那你会惊喜的发现, 卡线程了~~</p>
<p>在<strong>iOS</strong>当中, 能够高效的绘制并且加载到界面的图片是有一个大小限制的, 因为在<strong>iOS</strong>当中所有显示在屏幕上的图片最终都会被转化为<strong>OpenGL</strong>的纹理, 同时<strong>OpenGL</strong>是有一个最大纹理尺寸的限制, 根据设备的型号来决定, 通常是<strong>2048*2048</strong>或者<strong>4096*4096</strong>, 如果我们想在单个纹理中显示一个比这个限制尺寸还要大的图, 哪怕图片已经存在于内存当中, 我们也会遇到非常大的性能问题, 因为<strong>Core Animation</strong>是强制用<strong>CPU</strong>处理图片, 而不是<strong>GPU</strong>, 苹果为了解决这个问题, 于是乎有了<strong>CATiledLayer</strong>, 下面我们来看看<strong>Demo</strong>:</p>
<p>由于我不懂怎么把大图分解成小图, 这里就找张小一点的图用用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)addCATileLayer &#123;</span><br><span class="line">    </span><br><span class="line">    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, self.view.frame.size.width)];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:scrollView];</span><br><span class="line">    </span><br><span class="line">    CATiledLayer *tiledLayer = [CATiledLayer layer];</span><br><span class="line">    </span><br><span class="line">    tiledLayer.frame = CGRectMake(0, 0, 2048, 2048);</span><br><span class="line">    tiledLayer.delegate = self;</span><br><span class="line">    tiledLayer.contentsScale = [UIScreen mainScreen].scale;</span><br><span class="line">    </span><br><span class="line">    [scrollView.layer addSublayer:tiledLayer];</span><br><span class="line">    </span><br><span class="line">    scrollView.contentSize = tiledLayer.frame.size;</span><br><span class="line">    </span><br><span class="line">    [tiledLayer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx &#123;</span><br><span class="line">    </span><br><span class="line">    CGRect bounds = CGContextGetClipBoundingBox(ctx);</span><br><span class="line">    </span><br><span class="line">    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);</span><br><span class="line">    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);</span><br><span class="line">    </span><br><span class="line">    NSString *imageName = [NSString stringWithFormat:@&quot;image%02zd_%02zd&quot;, x, y];</span><br><span class="line">    </span><br><span class="line">    UIImage *tileImage = [UIImage imageNamed:imageName];</span><br><span class="line">    </span><br><span class="line">    UIGraphicsPushContext(ctx);</span><br><span class="line">    </span><br><span class="line">    [tileImage drawInRect:bounds];</span><br><span class="line">    </span><br><span class="line">    UIGraphicsPopContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/21.gif" alt="21"></p>
<p>这里我们注意到, 我默认是用<strong>Retina</strong>模式去显示图片的, 所以我们看起来这些图片会比较小, 如果你不想用<strong>Retina</strong>模式去显示, 你可以把代码中的一句代码删除即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tiledLayer.contentsScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>

<p>如果我们要做到像地图那样子放大缩小的话, 那就要自己头脑风暴一下, 然后想着如何去实现了~~</p>
<h3 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h3><p>在<strong>iOS 5</strong>版本中, 苹果加入了一个新的<strong>CALayer</strong>子类, 叫做<strong>CAEmitterLayer</strong>, 它是一个高性能的粒子引擎, 常用于制作实时效果的动画, 比如烟雾, 火, 雨等等之类的.</p>
<p>其实仔细想想, <strong>CAEmitterLayer</strong>看起来更像是一个容器, 里面装载着很多的<strong>CAEmitterCell</strong>, 这些<strong>CAEmitterCell</strong>定义了一个粒子效果, 然后在<strong>CAEmitterLayer</strong>的装载中显示出来.</p>
<p><strong>CAEmitterCell</strong>类似于一个普通的<strong>CALayer</strong>, 它有一个<strong>contents</strong>的属性, 可以定义为一个<strong>CGImage</strong>, 但不同于普通的<strong>CALayer</strong>的是它有一些课设置属性控制着表现和行为, 想了解更多的话, 大家可以自行去<strong>CAEmitterCell</strong>的头文件找找, 现在我们来看看<strong>Demo</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)addCAEmitterLayer &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 100,</span><br><span class="line">                                                                   self.view.frame.size.width,</span><br><span class="line">                                                                   self.view.frame.size.width)];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:contentView];</span><br><span class="line">    </span><br><span class="line">    CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];</span><br><span class="line">    </span><br><span class="line">    emitterLayer.frame = contentView.bounds;</span><br><span class="line">    emitterLayer.renderMode = kCAEmitterLayerAdditive;</span><br><span class="line">    emitterLayer.emitterPosition = CGPointMake(emitterLayer.frame.size.width / 2,</span><br><span class="line">                                               emitterLayer.frame.size.height / 2);</span><br><span class="line">    </span><br><span class="line">    [contentView.layer addSublayer:emitterLayer];</span><br><span class="line">    </span><br><span class="line">    CAEmitterCell *cell = [[CAEmitterCell alloc] init];</span><br><span class="line">    </span><br><span class="line">    cell.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;fire&quot;].CGImage);</span><br><span class="line">    cell.birthRate = 150;</span><br><span class="line">    cell.lifetime = 5.0;</span><br><span class="line">    cell.color = [UIColor colorWithRed:1.f</span><br><span class="line">                                 green:0.5f</span><br><span class="line">                                  blue:0.1f</span><br><span class="line">                                 alpha:1.0f].CGColor;</span><br><span class="line">    cell.alphaSpeed = -0.4f;</span><br><span class="line">    cell.velocity = 50.f;</span><br><span class="line">    cell.velocityRange = 50.f;</span><br><span class="line">    cell.emissionRange = M_PI * 2.0f;</span><br><span class="line">    </span><br><span class="line">    emitterLayer.emitterCells = @[cell];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/22.gif" alt="22"></p>
<p>这里补充一下知识点, <strong>CAEMitterCell</strong>基本上可以分为三种:</p>
<ul>
<li>粒子的某一属性的初始值, 比如:<strong>color</strong>属性指定了一个图片的混合色, 在<strong>Demo</strong>当中我们就设置了某个颜色.</li>
<li>粒子某一属性的变化范围, 比如:<strong>emissionRange</strong>, 在<strong>Demo</strong>当中, 我们设置为<strong>M_PI * 2.0f</strong>, 这意味着粒子可以从<strong>360°</strong>的任意位置反射出来.</li>
<li>粒子在指定值的时间线上的变化, 比如: <strong>alphaSpeed</strong>, 子啊<strong>Demo</strong>中, 我们设置为<strong>-0.4f</strong>, 这意味着, 每过一秒, 粒子的透明度就减少<strong>0.4</strong>, 这样子就有渐渐消失的效果啦.</li>
</ul>
<p>而<strong>CAEmitterLayer</strong>它是控制着整个粒子系统的位置和形状, 比如<strong>birthRate</strong>, <strong>lifetime</strong>和<strong>celocity</strong>, 当然, <strong>CAEMitterCell</strong>也有这些属性, 整个粒子系统都是这些属性以相乘的方式作用在一起, 这样子我们就可以用一个值来加速或者扩大整个粒子系统.</p>
<p>我们还需要知道另外两个比较重要的属性:</p>
<ul>
<li><p><strong>preservesDepth</strong>: 是否将一个<strong>3D</strong>的粒子系统平面化到一个图层, 或者可以在<strong>3D</strong>空间中混合其他图层.</p>
</li>
<li><p><strong>renderMode</strong>: 控制着粒子图片在视觉上是如何混合的, 在<strong>Demo</strong>当中, 我们设置为<strong>kCAEmitterLayerAdditive</strong>效果, 默认值为<strong>kCAEmitterLayerUnordered</strong>, 在开发当中需要什么样的效果, 还是得根据需求的来~</p>
</li>
</ul>
<h3 id="CAEAGLLayer"><a href="#CAEAGLLayer" class="headerlink" title="CAEAGLLayer"></a>CAEAGLLayer</h3><p>在<strong>iOS</strong>当中, 如果我们需要高性能的图形绘制, 那肯定是少不了去了解<strong>OpenGL</strong>, 这里说的是非游戏类的应用哈, 毕竟游戏有属于自己的一套渲染库, 说起<strong>OpenGL</strong>, 肯定有很多人觉得这个框架很厉害, 的确是的, 因为<strong>OpenGL</strong>是用<strong>C</strong>来写的, 直接和硬件进行通信, 但是呢, 也因为是用<strong>C</strong>所写的, 几乎有没有抽象出来的接口, 如果你要直接使用<strong>OpenGL</strong>来把图形显示在屏幕上, 那你就需要写非常多的复杂代码, 虽然<strong>OpenGL</strong>是非常强大的神器, 因为<strong>OpenGL</strong>是<strong>Core Animation</strong>和<strong>UIKit</strong>的基础.</p>
<p>在<strong>OpenGL</strong>中, 是没有对象和图层继承的概念, 它只是非常简单的去处理三角形, 在<strong>OpenGL</strong>中, 所有东西都是<strong>3D</strong>空间中有颜色和纹理的三角形, 感觉灰常的牛逼~</p>
<p>如果我们要高效的时候<strong>Core Animation</strong>, 那么我们就需要判断我们需要绘制哪些内容, 比如(矢量图形, 粒子, 文本等等), 但即使是我们选择了合适的图层去呈现这些内容, <strong>Core Animation</strong>中也不是每个类型的内容都被高度优化过, 所以要想得到高性能的去绘制, 那就比较蛋疼了.</p>
<p>在<strong>iOS 5</strong>中, 苹果为了解决这些蛋疼的问题, 加入了一个叫做<strong>GLKit</strong>的库, 它在一定层度上减少了使用<strong>OpenGL</strong>的复杂度, 提供了一个叫做<strong>GLKView</strong>的<strong>UIView</strong>子类, 帮我们处理大部分的设置内容和绘制工作, 有需要了解<strong>GLKit</strong>的朋友们可以去翻翻官方文档.</p>
<p>即使是如此, 我们还是需要使用到一个叫做<strong>CAEAGLLayer</strong>的<strong>CALayer</strong>子类, 酱紫我们才可以用来显示<strong>OpenGL</strong>的图形.</p>
<p>这里还需要提到一点, 虽然在大部分情况下, 我们不需要手动设置<strong>CAEAGLLayer</strong>(如果是用<strong>GLKView</strong>的话), 我们可以设置一个<strong>OpenGL ES 2.0</strong>的上下文, 这是大多数的用法, <strong>GLKit</strong>为我们提供许多便捷的方法, 比如设置顶点和片段的着色器之类的, 这些都是以类<strong>C</strong>语言叫做<strong>GLSL</strong>自包含在程序中, 同事在运行时载入到图形硬件中, 当然, <strong>GLSL</strong>的代码和设置<strong>CAEAGLLayer</strong>是一毛钱关系都没, 所以我们会用<strong>GLKBaseEffect</strong>类, 将着色的逻辑抽象出来就完事, 其他的事情, 还是和平常使用一样就哦了, 下面让我们来看看<strong>Demo</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">- (void)addCAEAGLLayer &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *glView = [[UIView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, self.view.frame.size.width)];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:glView];</span><br><span class="line">    </span><br><span class="line">    // 设置Context</span><br><span class="line">    self.glContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">    </span><br><span class="line">    [EAGLContext setCurrentContext:self.glContext];</span><br><span class="line">    </span><br><span class="line">    // 设置显示的Layer</span><br><span class="line">    self.glLayer = [CAEAGLLayer layer];</span><br><span class="line">    self.glLayer.frame = glView.bounds;</span><br><span class="line">    [glView.layer addSublayer:self.glLayer];</span><br><span class="line">    self.glLayer.drawableProperties = @&#123;kEAGLDrawablePropertyRetainedBacking : @NO,</span><br><span class="line">                                        kEAGLDrawablePropertyColorFormat : kEAGLColorFormatRGBA8&#125;;</span><br><span class="line">    </span><br><span class="line">    self.effect = [[GLKBaseEffect alloc] init];</span><br><span class="line">    </span><br><span class="line">    [self setUpBuffers];</span><br><span class="line">    [self drawFrame];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUpBuffers &#123;</span><br><span class="line">    </span><br><span class="line">    // 设置Frame</span><br><span class="line">    glGenFramebuffers(1, &amp;_framebuffer);</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class="line">    </span><br><span class="line">    // 设置颜色</span><br><span class="line">    glGenRenderbuffers(1, &amp;_colorRenderbuffer);</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);</span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">                              GL_RENDERBUFFER, _colorRenderbuffer);</span><br><span class="line">    </span><br><span class="line">    [self.glContext renderbufferStorage:GL_RENDERBUFFER</span><br><span class="line">                           fromDrawable:self.glLayer];</span><br><span class="line">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH,</span><br><span class="line">                                 &amp;_framebufferWidth);</span><br><span class="line">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT,</span><br><span class="line">                                 &amp;_framebufferHeight);</span><br><span class="line">    </span><br><span class="line">    // 检查是否成功</span><br><span class="line">    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%i&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)tearDownBuffers &#123;</span><br><span class="line">    </span><br><span class="line">    if (_framebuffer) &#123;</span><br><span class="line">        </span><br><span class="line">        glDeleteFramebuffers(1, &amp;_framebuffer);</span><br><span class="line">        _framebuffer = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_colorRenderbuffer) &#123;</span><br><span class="line">        </span><br><span class="line">        glDeleteRenderbuffers(1, &amp;_colorRenderbuffer);</span><br><span class="line">        _colorRenderbuffer = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)drawFrame &#123;</span><br><span class="line">    </span><br><span class="line">    // 绑定缓冲区</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</span><br><span class="line">    glViewport(0, 0, _framebufferWidth, _framebufferHeight);</span><br><span class="line">    </span><br><span class="line">    [self.effect prepareToDraw];</span><br><span class="line">    </span><br><span class="line">    // 清空屏幕</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glClearColor(0.0, 0.0, 0.0, 1.0);</span><br><span class="line">    </span><br><span class="line">    // 设置顶点</span><br><span class="line">    GLfloat vertices[] = &#123;</span><br><span class="line">        -0.5f, -0.5f, -1.0f,</span><br><span class="line">        0.0f, 0.5f, -1.0f,</span><br><span class="line">        0.5f, -0.5f, -1.0f&#125;;</span><br><span class="line">    </span><br><span class="line">    // 设置颜色值</span><br><span class="line">    GLfloat colors[] = &#123;</span><br><span class="line">        0.0f, 0.0f, 1.0f, 1.0f,</span><br><span class="line">        0.0f, 1.0f, 0.0f, 1.0f,</span><br><span class="line">        1.0f, 0.0f, 0.0f, 1.0f&#125;;</span><br><span class="line">    </span><br><span class="line">    // 开始画三角形</span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribColor);</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribPosition,</span><br><span class="line">                          3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribColor,</span><br><span class="line">                          4, GL_FLOAT, GL_FALSE, 0, colors);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line">    </span><br><span class="line">    // 渲染</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);</span><br><span class="line">    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self tearDownBuffers];</span><br><span class="line">    </span><br><span class="line">    [EAGLContext setCurrentContext:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/23.png" alt="23"></p>
<p>如果我们要做一个真正的<strong>OpenGL</strong>应用, </p>
<h3 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h3><p>最后一个图层类型叫做<strong>AVPlayerLayer</strong>, 看名字就知道它并不属于<strong>Core Animation</strong>里的一个部分, 它是由<strong>AVFoundation</strong>所提供, 但它和<strong>Core Animation</strong>紧密的结合在一起, 并且是<strong>CALayer</strong>的子类, 可以用来显示自定义内容.</p>
<p>实际上<strong>AVPlayerLayer</strong>是用来在<strong>iOS</strong>上播放视频的, 是属于<strong>MPMoivePlayer</strong>的底层实现, 提供了显示视频的底层支持.</p>
<p><strong>AVPlayerLayer</strong>使用起来比较简单, 我们可以直接来看看<strong>Demo</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)addAVPlayerLayer &#123;</span><br><span class="line">    </span><br><span class="line">    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;demo0&quot;</span><br><span class="line">                                         withExtension:@&quot;m4v&quot;];</span><br><span class="line">    </span><br><span class="line">    AVPlayer *player = [AVPlayer playerWithURL:url];</span><br><span class="line">    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br><span class="line">    </span><br><span class="line">    playerLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:playerLayer];</span><br><span class="line">    </span><br><span class="line">    [player play];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/24.gif" alt="24"></p>
<p>我们知道了<strong>AVPlayerLayer</strong>是<strong>CALayer</strong>的子类, 那么它应当也有父类的所有特性, 比如3D, 圆角, 有色边框, 蒙版, 阴影等等效果都有, 我们再原来的基础上再改改~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)addAVPlayerLayerTwo &#123;</span><br><span class="line">    </span><br><span class="line">    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;demo0&quot;</span><br><span class="line">                                         withExtension:@&quot;m4v&quot;];</span><br><span class="line">    </span><br><span class="line">    AVPlayer *player = [AVPlayer playerWithURL:url];</span><br><span class="line">    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br><span class="line">    </span><br><span class="line">    playerLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);</span><br><span class="line">    </span><br><span class="line">    [self.view.layer addSublayer:playerLayer];</span><br><span class="line">    </span><br><span class="line">    CATransform3D transform = CATransform3DIdentity;</span><br><span class="line">    transform.m34 = -1.0 / 500.0;</span><br><span class="line">    transform = CATransform3DRotate(transform, M_PI_4, 1, 1, 0);</span><br><span class="line">    </span><br><span class="line">    playerLayer.transform = transform;</span><br><span class="line">    playerLayer.masksToBounds = YES;</span><br><span class="line">    playerLayer.cornerRadius = 30.f;</span><br><span class="line">    playerLayer.borderColor = [UIColor blueColor].CGColor;</span><br><span class="line">    playerLayer.borderWidth = 10.f;</span><br><span class="line">    </span><br><span class="line">    [player play];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CainLuo/CoreAnimation/master/6.SpecializedLayers/images/25.gif" alt="25"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了, 这次我们讲到这里了, 在这章里, 我们认识<strong>CALayer</strong>的一些子类, 以及它们的一些特性, 方便我们在开发当中实现我们想要的效果时提供了多一些的参考, 但是呢, 这还远远不够, 我们只是初步的去了解这些<strong>CALayer</strong>子类的皮毛, 单单<strong>CATiledLayer</strong>和<strong>CAEMitterLayer</strong>两个子类我们都可以单独抽出来写一长串的东东, 这个还是后面再说吧, 重点是, 我们要记住, <strong>CALayer</strong>的用处非常之大, 虽然有一些<strong>CALayer</strong>的子类并没有为所有可能出现的场景进行优化, 这个就要靠我们自己的头脑风暴去思考如何才能更好的去优化了.</p>
<h2 id="工程地址"><a href="#工程地址" class="headerlink" title="工程地址"></a>工程地址</h2><p>项目地址: <a href="https://github.com/CainLuo/CoreAnimation" target="_blank" rel="noopener">https://github.com/CainLuo/CoreAnimation</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                    
                        <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='345ba2c1d8d1b80e1a7c'
        data-cs='170576df7da58eb1ff647403d422c689a68072c7'
        data-r='cainluo.github.io'
        data-o='CainLuo'
        data-a='CainLuo'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAShapeLayer"><span class="toc-number">2.</span> <span class="toc-text">CAShapeLayer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个CGPath"><span class="toc-number">2.1.</span> <span class="toc-text">创建一个CGPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#圆角"><span class="toc-number">2.2.</span> <span class="toc-text">圆角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CATextLayer"><span class="toc-number">2.3.</span> <span class="toc-text">CATextLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rich-Text"><span class="toc-number">2.4.</span> <span class="toc-text">Rich Text</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leading-and-Kerning"><span class="toc-number">2.5.</span> <span class="toc-text">Leading and Kerning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-UILabel-Replacement"><span class="toc-number">2.6.</span> <span class="toc-text">A UILabel Replacement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CATransformLayer"><span class="toc-number">2.7.</span> <span class="toc-text">CATransformLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAGradientLayer"><span class="toc-number">2.8.</span> <span class="toc-text">CAGradientLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAReplicatorLayer"><span class="toc-number">2.9.</span> <span class="toc-text">CAReplicatorLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflections"><span class="toc-number">2.10.</span> <span class="toc-text">Reflections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAScrollLayer"><span class="toc-number">2.11.</span> <span class="toc-text">CAScrollLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CATiledLayer"><span class="toc-number">2.12.</span> <span class="toc-text">CATiledLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAEmitterLayer"><span class="toc-number">2.13.</span> <span class="toc-text">CAEmitterLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAEAGLLayer"><span class="toc-number">2.14.</span> <span class="toc-text">CAEAGLLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVPlayerLayer"><span class="toc-number">2.15.</span> <span class="toc-text">AVPlayerLayer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工程地址"><span class="toc-number">4.</span> <span class="toc-text">工程地址</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/iOSDevelopment/js/plugin.js"></script>
<script src="/iOSDevelopment/js/diaspora.js"></script>
<link rel="stylesheet" href="/iOSDevelopment/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/iOSDevelopment/photoswipe/default-skin/default-skin.css">
<script src="/iOSDevelopment/photoswipe/photoswipe.min.js"></script>
<script src="/iOSDevelopment/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
